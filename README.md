# 🚀 조회 성능 개선하기

## A. 쿼리 연습
> 활동중인(Active) 부서의 현재 부서관리자 중 연봉 상위 5위안에 드는 사람들이 최근에 각 지역별로 언제 퇴실했는지 조회해보세요.
(사원번호, 이름, 연봉, 직급명, 지역, 입출입구분, 입출입시간)

### 첫 번째 쿼리 작성 시도
```sql
SELECT
	고연봉관리자.사원번호 as 사원번호,
    고연봉관리자.이름 as 이름,
    고연봉관리자.연봉 as 연봉,
    고연봉관리자.직급명 as 직급명,
    사원출입기록.지역 as 지역,
    사원출입기록.입출입구분 as 입출입구,
    사원출입기록.입출입시간 as 입출입시간
FROM (
    SELECT 
		사원.사원번호,
        사원.이름,
        급여.연봉,
        직급.직급명
	FROM 
		부서
        JOIN 부서관리자 ON 부서.부서번호 = 부서관리자.부서번호
        JOIN 사원 ON 부서관리자.사원번호 = 사원.사원번호
        JOIN 직급 ON 부서관리자.사원번호 = 직급.사원번호
        JOIN 급여 ON 부서관리자.사원번호 = 급여.사원번호
	WHERE		
		  부서.비고='Active'
		  AND 부서관리자.시작일자 < CURDATE()
		  AND CURDATE() < 부서관리자.종료일자 
	ORDER BY
		급여.연봉 DESC
	LIMIT
		5
    ) AS 고연봉관리자 
    JOIN 사원출입기록 ON 고연봉관리자.사원번호 = 사원출입기록.사원번호
WHERE
	사원출입기록.입출입구분 = 'O'
ORDER BY
	고연봉관리자.연봉 DESC
;
```

동작은 하나, 아무런 결과가 조회되지 않았다.
서브쿼리 내부에서 문제가 발생하고 있는 것 같았다.

### 두 번째 쿼리 작성 시도

```sql
SELECT
	고연봉관리자.사원번호 as 사원번호,
    고연봉관리자.이름 as 이름,
    고연봉관리자.연봉 as 연봉,
    고연봉관리자.직급명 as 직급명,
    사원출입기록.지역 as 지역,
    사원출입기록.입출입구분 as 입출입구,
    사원출입기록.입출입시간 as 입출입시간
FROM (
    SELECT 
		사원.사원번호,
        사원.이름,
        급여.연봉,
        직급.직급명
	FROM 
		부서
        JOIN 부서관리자 ON 부서.부서번호 = 부서관리자.부서번호
        JOIN 사원 ON 부서관리자.사원번호 = 사원.사원번호
        JOIN 직급 ON 부서관리자.사원번호 = 직급.사원번호
        JOIN 급여 ON 부서관리자.사원번호 = 급여.사원번호
	WHERE		
		부서.비고='Active'
		AND CURDATE() BETWEEN 부서관리자.시작일자 AND 부서관리자.종료일자    
		AND CURDATE() BETWEEN 직급.시작일자 AND 직급.종료일자
		AND CURDATE() BETWEEN 급여.시작일자 AND 급여.종료일자
	ORDER BY
		급여.연봉 DESC
	LIMIT
		5
    ) AS 고연봉관리자 
    JOIN 사원출입기록 ON 고연봉관리자.사원번호 = 사원출입기록.사원번호
WHERE
	사원출입기록.입출입구분 = 'O'
ORDER BY
	고연봉관리자.연봉 DESC
;
```

서브 쿼리의 WHERE절 조건 '종료일자'가 너무 러프한거 같아서, 부서사원_매핑 테이블을 제외한 모든 테이블에서 사용되는 시작일자/종료일자를 제한조건으로 사용했다. 그러고 나니 원하는 결과를 얻을 수 있었다. 그러나 서브쿼리의 WHERE절에서 이루어지는 범위 탐색이 애매하다고 느껴졌다.

현재는 3개의 시작일자~종료일자 범위 탐색이 운이 좋게 맞아떨어져서 `Vishwani`, `Hauke`, `Isamu`, `Leon`, `Karsten` 5명이 집계된 것이고, 운이 나쁘면 중복된 사원이 집계될 수도 있었을거란 생각이 들었다. 

검프가 내부 데이터 조회를 도와준 덕분에 알아보니, 실제 내부 데이터에 시작일자~종료일자 가 겹치는 데이터가 존재하지 않았다. 때문에 BETWEEN을 이용한 WHERE 절에서 중복된 사원이 모두 제거된 것이었다. 그러나 "기간이 서로 겹치는 데이터가 존재하지 않을 것이라고 온전히 믿어도 될까?" 라는 의심 때문에 GROUP BY 절로 사원과 직급명을 묶고, 최대 급여.연봉 만 확인하도록 처리를 하려했다.

그러나 **CU께 "쿼리를 작성할 때, 내부 데이터를 신뢰하고 쿼리를 작성해야하나요?" 라는 질문을 드렸을 때 "그렇다." 라는 답변**을 받고 중복검증 쿼리 추가를 하지 않았다. 왜 내부 데이터를 신뢰하고 쿼리를 작성해야하는가?

내부 데이터를 신뢰하지 못하고 검증 관련 쿼리를 하나씩 추가하게 되면 점차 데이터베이스에 의존적인 형태로 쿼리가 작성되게 된다. 
데이터의 신뢰성이 떨어진다면 데이터 정제를 다시 수행하거나, 데이터가 데이터베이스로 전달되기 전 애플리케이션 레벨에서 검증 전처리를 확실하게 수행하는 것이 좋은 방향이다. (검증 쿼리가 추가되는 만큼 쿼리의 성능 이슈도 생길 수 있을거 같았는데, 그것보다 프로그램이 점점 데이터베이스에 의존적인 형태로 바뀌는게 가장 위험하다고 하셨다.)

최종적으로 아래 쿼리로 마무리 지었다.

```sql
SELECT
	고연봉관리자.사원번호 as 사원번호,
    고연봉관리자.이름 as 이름,
    고연봉관리자.연봉 as 연봉,
    고연봉관리자.직급명 as 직급명,
    사원출입기록.지역 as 지역,
    사원출입기록.입출입구분 as 입출입구,
    사원출입기록.입출입시간 as 입출입시간
FROM (
	SELECT 
		사원.사원번호,
		사원.이름,
		MAX(급여.연봉) AS 연봉,
		직급.직급명
	FROM 
		부서
		JOIN 부서관리자 ON 부서.부서번호 = 부서관리자.부서번호
		JOIN 사원 ON 부서관리자.사원번호 = 사원.사원번호
		JOIN 직급 ON 부서관리자.사원번호 = 직급.사원번호
		JOIN 급여 ON 부서관리자.사원번호 = 급여.사원번호
	WHERE		
		부서.비고='Active'
		AND CURDATE() BETWEEN 부서관리자.시작일자 AND 부서관리자.종료일자    
		AND CURDATE() BETWEEN 직급.시작일자 AND 직급.종료일자
		AND CURDATE() BETWEEN 급여.시작일자 AND 급여.종료일자 
	GROUP BY
		사원.사원번호, 직급.직급명
	ORDER BY
		MAX(급여.연봉) DESC
	LIMIT
		5
    ) AS 고연봉관리자 
    JOIN 사원출입기록 ON 고연봉관리자.사원번호 = 사원출입기록.사원번호
WHERE
	사원출입기록.입출입구분 = 'O'
ORDER BY
	고연봉관리자.연봉 DESC
;
```
| 사원번호 | 이름 | 연봉 | 직급명 | 지역 | 입출입구 | 입출입시간 |
|:--------:|:----:|:-----:|:-------:|:-----:|:-------:|:----------:|
| 110039 | Vishwani | 106491 | Manager | b | O | 2020-08-05 21:01:50 |
| 110039 | Vishwani | 106491 | Manager | d | O | 2020-07-06 11:00:25 |
| 110039 | Vishwani | 106491 | Manager | a | O | 2020-09-05 20:30:07 |
| 111133 | Hauke | 101987 | Manager | a | O | 2020-01-24 02:59:37 |
| 111133 | Hauke | 101987 | Manager | b | O | 2020-05-07 16:30:37 |
| 110114 | Isamu | 83457 | Manager | a | O | 2020-05-29 19:38:12 |
| 110114 | Isamu | 83457 | Manager | b | O | 2020-09-03 01:33:01 |
| 110114 | Isamu | 83457 | Manager | d | O | 2020-04-25 08:28:54 |
| 110114 | Isamu | 83457 | Manager | c | O | 2020-11-12 02:29:00 |
| 110567 | Leon | 74510 | Manager | a | O | 2020-10-17 19:13:31 |
| 110567 | Leon | 74510 | Manager | b | O | 2020-02-03 10:51:15 |
| 110228 | Karsten | 65400 | Manager | a | O | 2020-07-13 11:42:49 |
| 110228 | Karsten | 65400 | Manager | b | O | 2020-09-23 06:07:01 |
| 110228 | Karsten | 65400 | Manager | d | O | 2020-01-11 22:29:04 |

> 0.443 sec

### 쿼리 성능 최적화
![image](https://user-images.githubusercontent.com/37354145/137291146-db178d9f-8432-4940-abd4-f1beb9123633.png)

```
# id, select_type, table, partitions, type, possible_keys, key, key_len, ref, rows, filtered, Extra
'1', 'PRIMARY', '<derived2>', NULL, 'ALL', NULL, NULL, NULL, NULL, '2', '100.00', 'Using temporary; Using filesort'
'1', 'PRIMARY', '사원출입기록', NULL, 'ALL', NULL, NULL, NULL, NULL, '658935', '1.00', 'Using where; Using join buffer (Block Nested Loop)'
'2', 'DERIVED', '부서', NULL, 'ALL', 'PRIMARY', NULL, NULL, NULL, '9', '11.11', 'Using where; Using temporary; Using filesort'
'2', 'DERIVED', '부서관리자', NULL, 'ref', 'PRIMARY,I_부서번호', 'I_부서번호', '12', 'tuning.부서.부서번호', '2', '11.11', 'Using where'
'2', 'DERIVED', '직급', NULL, 'ref', 'PRIMARY', 'PRIMARY', '4', 'tuning.부서관리자.사원번호', '1', '11.11', 'Using where'
'2', 'DERIVED', '사원', NULL, 'eq_ref', 'PRIMARY', 'PRIMARY', '4', 'tuning.부서관리자.사원번호', '1', '100.00', NULL
'2', 'DERIVED', '급여', NULL, 'ref', 'PRIMARY', 'PRIMARY', '4', 'tuning.부서관리자.사원번호', '9', '11.11', 'Using where'
```

EXPLAIN 명령을 통해 실행 계획을 살펴보았을 때 `사원출입기록`에서 풀 스캔이 일어나며, 그 행 개수가 굉장히 많은 것을 확인할 수 있었다. 이 때문에 `사원출입기록`의 `사원번호`를 인덱싱 하는 것으로 성능을 개선하고자 했다.

```sql
CREATE INDEX idx_사원출입기록_사원번호 ON 사원출입기록 (사원번호);
```

그 후 조회 쿼리를 다시 수행했다.

| 사원번호 | 이름 | 연봉 | 직급명 | 지역 | 입출입구 | 입출입시간 |
|:--------:|:----:|:-----:|:-------:|:-----:|:-------:|:----------:|
| 110039 | Vishwani | 106491 | Manager | b | O | 2020-08-05 21:01:50 |
| 110039 | Vishwani | 106491 | Manager | d | O | 2020-07-06 11:00:25 |
| 110039 | Vishwani | 106491 | Manager | a | O | 2020-09-05 20:30:07 |
| 111133 | Hauke | 101987 | Manager | a | O | 2020-01-24 02:59:37 |
| 111133 | Hauke | 101987 | Manager | b | O | 2020-05-07 16:30:37 |
| 110114 | Isamu | 83457 | Manager | a | O | 2020-05-29 19:38:12 |
| 110114 | Isamu | 83457 | Manager | b | O | 2020-09-03 01:33:01 |
| 110114 | Isamu | 83457 | Manager | d | O | 2020-04-25 08:28:54 |
| 110114 | Isamu | 83457 | Manager | c | O | 2020-11-12 02:29:00 |
| 110567 | Leon | 74510 | Manager | a | O | 2020-10-17 19:13:31 |
| 110567 | Leon | 74510 | Manager | b | O | 2020-02-03 10:51:15 |
| 110228 | Karsten | 65400 | Manager | a | O | 2020-07-13 11:42:49 |
| 110228 | Karsten | 65400 | Manager | b | O | 2020-09-23 06:07:01 |
| 110228 | Karsten | 65400 | Manager | d | O | 2020-01-11 22:29:04 |

> 0.0031 sec

![image](https://user-images.githubusercontent.com/37354145/137292141-890d47c5-79dd-4b26-b557-4fb4c8937344.png)


인덱싱 후에도 여전히 풀스캔이 발생하나, 실제 데이터 조회는 9개 행만 이루어졌다. 
이에 따라 결과 조회 속도가 `0.0031 sec`로 개선되었다.

<br>
